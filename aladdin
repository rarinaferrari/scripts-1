Вопросы для Django Middle

Developer

Уровни вопросов: легкий, средний, сложный

Python

Структуры данных

В Python существуют четыре встроенных структуры данных: список, кортеж, словарь
и множество.
	Что такое исключения и как они работают?
• Ошибки, обнаруженные во время выполнения программы,
называются исключениями, не являются безусловно фатальными и могут
генерироваться и перехватываться.
• Исключения в Python обычно применяются для:
◦ обработки ошибок
◦ уведомления о событиях
◦ обработки особых случаев
◦ действий при завершении
◦ редких потоков управления
	Какая иерархия у исключений?
	Что такое рекурсия и зачем ее использовать?
• Рекурсия - это вызов функции из неё же самой непосредственно (простая
рекурсия) или через другие функции (сложная или косвенная рекурсия),
например, функция A вызывает функцию B, а функция B — функцию A.
• Количество вложенных вызовов функции или процедуры называется глубиной
рекурсии.
• Рекурсивная программа позволяет описать повторяющееся или даже
потенциально бесконечное вычисление, причём без явных повторений частей
программы и использования циклов.
Что такое итерирование и в чем ее отличие от рекурсии?
• Повторяющееся выполнение одного и того же блока кода снова и снова
называется итерацией.
• Объект считается итерируемым, если он является или физически хранящейся
последовательностью, или объектом, который производит по одному результату
за раз в контексте итерационного инструмента, подобного циклу for .
• Любой объект с методом __next__ для перехода на следующий результат,
который генерирует исключение StopIteration при достижении конца серии
результатов, считается итератором.
• Рекурсивные функции занимают больше места в памяти по сравнению с
итеративными из-за постоянного добавления новых слоев в стек в памяти.
Однако их производительность куда выше (рекурсия может быть медленной, если
реализована неправильно)
В чем отличие оператора is от оператора == ?
• == / != проверяет равенство (по значению), а is / is not проверяет
идентичность двух объектов, то есть проверяет адреса их памяти.
Что такое lambda-функции?
• В Python лямбда-выражение позволяет создавать анонимные функции - функции,
которые не привязаны к имени.
• В анонимной функции:
◦ может содержаться только одно выражение
◦ могут передаваться сколько угодно аргументов
В чем отличие генератора от итератора?
• Итератор – это интерфейс доступа к элементам коллекций и потоков данных. Он
требует реализации единственного метода – «дай мне следующий элемент».
Если вы пишите свой итератор на Python 3 вам нужно реализовать в классе метод
__next__ . Если элементы исчерпаны итератор возбудит исключение
StopIteration .
• Генератор – это итератор, но не наоборот. Отличия:
1. Генераторы можно прочитать только 1 раз, потому что обычно генераторы не
хранят значения в памяти, а генерируют их налету (отсюда и название).
2. Если генератор «закончился» (т.е. просто вышли из функции генератора в
конце его кода или по return), то автоматически возбуждается исключение
StopIteration .
3. У генераторов есть дополнительные методы, которые позволяют передавать
внутрь генератора данные или возбуждать внутри него исключения.
Что такое контекстный менеджер и как он работает?
• Контекстные менеджеры позволяют задать поведение при работе с конструкцией
with: при входе и выходе из блока. Это упрощает работу с ресурсами в части их
захвата и освобождения; транзакциями, когда нужно либо полностью закончить
транзакцию, либо откатить ее целиком.
with open('file.txt', 'w') as file_data: file_data.write('hello')
1. Оператор with сохраняет метод __exit__ класса File .
2. Вызывается метод __enter__ класса File .
3. __enter__ открывает файл и возвращает его.
4. Дескриптор открытого класса передается в file_data .
5. В файл записываются данные через метод write .
6. Вызывается сохраненный метод __exit__ , который закрывает файл.
Как создать свой контекстный менеджер?
1. Необходимый минимум функциональности контекстного менеджера требует
методов __enter__ и __exit__
2. Вместо написания класса, мы можем реализовать менеджер контекста из
функции-генератора
from contextlib import contextmanager @contextmanager def
open_file(name): f = open(name, 'w') yield f f.close()
Что такое словарь и какие типы данных могут быть ключами словаря?
• Словари в Python - неупорядоченные коллекции произвольных объектов с
доступом по ключу. Их иногда ещё называют ассоциативными массивами или
хеш-таблицами.
• В качестве ключей словаря могут использоваться любые хешируемые объекты -
объекты которые с момента появления в программе и до их утилизации не
меняют свой хеш (уникальный идентификатор). К таким объектам относятся:
числа (int, float и complex), строки (str, bytes), замороженные множества (frozenset)
и кортежи (tuple), если все их элементы являются хешируемыми.
Что такое объект в Python?
• В Python любой экземпляр класса это объект, но далеко не все объекты это
просто экземпляры класса. К примеру, объектом является также класс,
экземпляры этого класса (которые в ООП и называются объектами) тоже объекты,
но лишь одни из возможных видов объектов в Python. Существует первородный
класс object и все остальные типы (включая пользовательские и встроенные)
являются наследниками этого класса.
Что такое функция?
• Функция в python - объект, принимающий аргументы и возвращающий значение.
Обычно функция определяется с помощью инструкции def .
Что такое чистые функции и функции высшего порядка?
• Чистая функция — это функция, которая является детерминированной и не
обладает никакими побочными эффектами. То есть чтобы функция являлась
чистой она должна быть детерминированной — то есть каждый раз при
одинаковом наборе аргументов выдавать одинаковый результат.
def sum(a,b): return a+b
• Функция высшего порядка — в программировании функция, принимающая в
качестве аргументов другие функции или возвращающая другую функцию в
качестве результата. Основная идея состоит в том, что функции имеют тот же
статус, что и другие объекты данных. Использование функций высшего порядка
приводит к абстрактным и компактным программам, принимая во внимание
сложность производимых ими вычислений.
• Следующий исходный код, написанный на Python, содержит функцию высшего
порядка g(), которая в качестве первого аргумента принимает функцию. В
результате на экран будет выведено «100» (результат вычисления (7+3)×(7+3)).
def f(x): return x + 3 def g(function, x): return function(x) *
function(x) print(g(f, 7))
Что такое hash и map?
• Метод hash() возвращает хеш-значение объекта, если оно есть. Значения хэша
– это просто целые числа, которые используются для быстрого сравнения ключей
словаря во время поиска в словаре. Внутренне метод вызывает __hash __()
объекта, который установлен по умолчанию для любого объекта.
• Встроенная функция map() позволяет обрабатывать и преобразовывать все
элементы в итерируемом объекте без использования явного цикла for , методом,
широко известным как сопоставление (mapping). map() полезен, когда нужно
применить функцию преобразования к каждому элементу в коллекции или в
массиве и преобразовать их в новый массив.
Что такое comprehensions?
• List comprehensions — это встроенный в Python механизм генерации списков. У
него только одна задача — это построить список. Списковое включение строит
список из любого итерируемого типа, преобразуя (фильтруя) поступаемые
значения.
Что такое декораторы и как они работают?
• Декоратор — это функция, которая позволяет обернуть другую функцию для
расширения её функциональности без непосредственного изменения её кода.
• Декоратор — это паттерн проектирования (design pattern) в Python, а также
функция второго уровня, то есть принимающая другие функции в качестве
переменных и возвращающая их.
• И в сам декоратор, и в функцию-обёртку можно передать и позиционные,
и именованные аргументы — args и kwargs соответственно.
• Декораторы работают не только с функциями, но и с классами и методами.
Какие встроенные декораторы существуют?
• Декоратор @property облегчает создание свойств в классах Python. Свойства
выглядят как обычные атрибуты (поля) класса, но при их чтении
вызывается геттер (getter), при записи – сеттер (setter), а при удалении –
делитер (deleter). Геттер и делитер опциональны.
• Методы могут быть не только у экземпляра класса, но и у самого класса, которые
вызываются без какого-то экземпляра (без self ). Декораторы @staticmethod и
@classmethod как раз делают метод таким (статическим или классовым).
• Декоратор @functools.lru_cache запоминает результаты функции для данного
набора аргументов, при следующем вызове уже не выполняет функцию, а достает
результат из кэша. Размер кэша регулируется. Часто используемые элементы
остаются в кэше, редкие – вытесняются, если размер доходит до максимального.
• Декоратор @contextlib.contextmanager позволяет получить из генератора –
контекст менеджер.
• Декоратор @functools.wraps полезен при разработке других декораторов.
Передает имя, документацию и прочую мета-информацию из декорируемой
функции к ее обертке.
• Декоратор @atexit.register регистрирует функцию для вызова ее при
завершении работы процесса Python.
Что такое многопроцессорность, многопоточность и асинхронность?
• Многопроцессорность - это использование двух или более процессорных блоков
в одной компьютерной системе. Это лучший способ получить полный потенциал
от нашего оборудования, используя полное количество процессорных ядер,
доступных в нашей компьютерной системе.
• Многопоточность - это способность ЦП управлять использованием
операционной системы путем одновременного выполнения нескольких потоков.
Основная идея многопоточности заключается в достижении параллелизма путем
разделения процесса на несколько потоков.
• Асинхронность — это возможность выполнения программой задач и процессов
без ожидания их завершения. То есть если предыдущий процесс все еще
находится на этапе выполнения, асинхронная программа может легко перейти к
обработке следующих задач.
Приведите пример алгоритмов
1. Обзор алгоритмов сортировки массива:
• пузырьковая сортировка,
• сортировка выбором,
• сортировка вставкой,
• сортировка Шелла,
• быстрая сортировка,
• сортировка слиянием.
2. Жадный алгоритм.
3. Алгоритмы поиска пути:
• обход в глубину,
• обход в ширину.
4. Транспортный алгоритм — алгоритм Дейкстры.
Как работают filter и collections?
1. Функция filter применяет функцию ко всем элементам последовательности и
возвращает итератор с теми объектами, для которых функция вернула True .
Например, вернуть только те строки, в которых находятся числа:
In [1]: list_of_strings = ['one', 'two', 'list', '', 'dict', '100',
'1', '50'] In [2]: filter(str.isdigit, list_of_strings) Out[2]: <filter
at 0xb45eb1cc> In [3]: list(filter(str.isdigit, list_of_strings))
Out[3]: ['100', '1', '50']
2. collections.Counter - вид словаря, который позволяет нам считать количество
неизменяемых объектов (в большинстве случаев, строк)
3. collections.deque - создаёт очередь из итерируемого объекта с максимальной
длиной maxlen. Очереди очень похожи на списки, за исключением того, что
добавлять и удалять элементы можно либо справа, либо слева.
4. collections.defaultdict ничем не отличается от обычного словаря за
исключением того, что по умолчанию всегда вызывается функция, возвращающая
значение
5. collections.OrderedDict - ещё один похожий на словарь объект, но он помнит
порядок, в котором ему были даны ключи
6. collections.namedtuple позволяет создать тип данных, ведущий себя как
кортеж, с тем дополнением, что каждому элементу присваивается имя, по
которому можно в дальнейшем получать доступ
В чем отличие метода __new__ от метода __init__ ?
• Инстанцирование обычного объекта происходит в 2 этапа: сначала его создание,
потом инициализация. Соответственно, сначала запускается метод класса
__new__ , который возвращает объект данного класса, потом выполняется метод
класса __init__ , который инициализирует уже созданный объект.
Какие концепции ООП существуют и как они реализованы в Python?
1. Инкапсуляция
Все объекты в Python инкапсулируют внутри себя данные и методы работы с
ними, предоставляя публичные интерфейсы для взаимодействия.
Атрибут может быть объявлен приватным (внутренним) с помощью нижнего
подчеркивания перед именем, но настоящего скрытия на самом деле не
происходит – все на уровне соглашений.
2. Наследование
Язык программирования Python реализует как стандартное одиночное
наследование так и множественное
3. Полиморфизм
Все методы в языке изначально виртуальные. Это значит, что дочерние классы
могут их переопределять и решать одну и ту же задачу разными путями, а
конкретная реализация будет выбрана только во время исполнения программы.
Такие классы называют полиморфными.
Что такое множественное наследование и как оно реализовано в Python?
1. Множественное наследование - это возможность у класса потомка наследовать
функционал не от одного, а от нескольких родителей
2. В Python3 для определения порядка наследования используется алгоритм поиска
в ширину, а в Python второй версии используется алгоритм поиска в глубину
Что такое магические методы и для чего они нужны?
1. Магические методы - это методы, которые вызываются неявно во время вызова
функций или выполнения различных операций
2. __init__ используется для инициализации объектов
3. __add__ дает нам возможность доступа к встроенной функции синтаксиса
символа +
4. __eq__ определяет поведение для оператора равенства ==
5. __ne__ определяет поведение для оператора неравенства !=
6. __lt__ определяет поведение для оператора “менее чем” <
7. __gt__ определяет поведение для оператора “более чем больше чем” >
8. __le__ определяет поведение для оператора “меньше или равно” <=
9. __ge__ определяет поведение для оператора “большего или равно” >=
10. __repr__ выдает текстовое или строковое представление сущности или объекта
Что такое абстрактные классы?
1. Абстрактным называется класс, который содержит один и более абстрактных
методов.
2. Абстрактным называется объявленный, но не реализованный метод.
3. Абстрактные классы не могут быть инстанциированы, от них нужно унаследовать,
реализовать все их абстрактные методы и только тогда можно создать экземпляр
такого класса.
4. В Python отсутствует встроенная поддержка абстрактных классов, для этой цели
используется модуль abc (Abstract Base Class)
Для чего нужны слоты в классах и как можно ограничить количество атрибутов в
классе?
• Магический метод __slots__ позволяет задать ограниченный набор атрибутов,
которыми будет обладать экземпляр класс
class SlotsClass: __slots__ = ('foo', 'bar') >>> obj = SlotsClass() >>>
obj.foo = 5 >>> obj.foo # 5 >>> obj.another_attribute = 'Elvis has left
the building' Traceback (most recent call last): File "python", line 5,
in <module> AttributeError: 'SlotsClass' object has no attribute
'another_attribute'
Что такое метаклассы и где они могут понадобиться?
1. Метаклассы – это классы, экземпляры которых являются классами
2. Основная цель метаклассов — автоматически изменять класс
в момент создания
3. Основное применение метаклассов это создание API. Типичный пример — Django
ORM
Что такое модули и пакеты в Python?
1. Под модулем в Python понимается файл с расширением .py . Модули
предназначены для того, чтобы в них хранить часто используемые функции,
классы, константы и т.п. Можно условно разделить модули и программы:
программы предназначены для непосредственного запуска, а модули для
импортирования их в другие программы. Стоит заметить, что модули могут быть
написаны не только на языке Python, но и на других языках (например C).
2. List
Пакет в Python – это каталог, включающий в себя другие каталоги и модули, но при
этом дополнительно содержащий файл init.py . Пакеты используются для
формирования пространства имен, что позволяет работать с модулями через
указание уровня вложенности (через точку). Для импортирования пакетов
используется тот же синтаксис, что и для работы с модулями.
Что такое SOLID?
• SOLID — это аббревиатура пяти основных принципов проектирования в
объектно-ориентированном программировании
• Принцип единственной обязанности / ответственности (single responsibility
principle / SRP) обозначает, что каждый объект должен иметь одну обязанность
и эта обязанность должна быть полностью инкапсулирована в класс. Все его
сервисы должны быть направлены исключительно на обеспечение этой
обязанности.
• Принцип открытости / закрытости (open-closed principle / OCP) декларирует,
что программные сущности (классы, модули, функции и т. п.) должны быть
открыты для расширения, но закрыты для изменения. Это означает, что эти
сущности могут менять свое поведение без изменения их исходного кода.
• Принцип подстановки Барбары Лисков (Liskov substitution principle / LSP)
в формулировке Роберта Мартина: «функции, которые используют базовый тип,
должны иметь возможность использовать подтипы базового типа не зная
об этом».
• Принцип разделения интерфейса (interface segregation principle / ISP)
в формулировке Роберта Мартина: «клиенты не должны зависеть от методов,
которые они не используют». Принцип разделения интерфейсов говорит о том,
что слишком «толстые» интерфейсы необходимо разделять на более маленькие
и специфические, чтобы клиенты маленьких интерфейсов знали только
о методах, которые необходимы им в работе. В итоге, при изменении метода
интерфейса не должны меняться клиенты, которые этот метод не используют.
• Принцип инверсии зависимостей (dependency inversion principle / DIP) —
модули верхних уровней не должны зависеть от модулей нижних уровней, а оба
типа модулей должны зависеть от абстракций; сами абстракции не должны
зависеть от деталей, а вот детали должны зависеть от абстракций.
Что такое DRY?
1. DRY — don’t repeat yourself / не повторяйте себя
2. Следование принципу программирования «DRY» позволяет добиться высокой
сопровождаемости проекта, простоты внесения изменений и качественного
тестирования
Что такое KISS?
1. KISS — это принцип проектирования и программирования, при котором простота
системы декларируется в качестве основной цели или ценности. Есть два
варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный
«keep it short and simple».
2. В проектировании следование принципу KISS выражается в том, что:
• не имеет смысла реализовывать дополнительные функции, которые не будут
использоваться вовсе или их использование крайне маловероятно, как
правило, большинству пользователей достаточно базового функционала,
а усложнение только вредит удобству приложения;
• не стоит перегружать интерфейс теми опциями, которые не будут нужны
большинству пользователей, гораздо проще предусмотреть для них
отдельный «расширенный» интерфейс (или вовсе отказаться от данного
функционала);
• бессмысленно делать реализацию сложной бизнес-логики, которая учитывает
абсолютно все возможные варианты поведения системы, пользователя
и окружающей среды, — во-первых, это просто невозможно, а вовторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего
иррационально с коммерческой точки зрения.
3. В программировании следование принципу KISS можно описать так:
• не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь
вовремя остановиться;
• бессмысленно закладывать в проект избыточные функции «про запас»,
которые может быть когда-нибудь кому-либо понадобятся (тут скорее
правильнее
подход согласно принципу YAGNI
);
• не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара
функций;
• декомпозиция чего-то сложного на простые составляющие —
это архитектурно верный подход (тут KISS перекликается с
DRY
);
• абсолютная математическая точность или предельная детализация нужны
не всегда — большинство систем создаются не для запуска космических
шаттлов, данные можно и нужно обрабатывать с той точностью, которая
достаточна для качественного решения задачи, а детализацию выдавать
в нужном пользователю объёме, а не в максимально возможном объёме.
Какие практики и инструменты тестирования существуют?
1.
https://habr.com/ru/company/yandex/blog/517266/
2. Тесты бывают ручные и автоматизированные
3. Юнит-тесты проверяют очень маленький кусок кода, обычно конкретную функцию,
и чаще всего их пишут разработчики, которые хорошо понимают возможные
крайние случаи для своего стека технологий. Интеграционные тесты проверяют
взаимодействие сразу нескольких систем. Они могут создаваться и
поддерживаться как разработчиками и тестировщиками, так и аналитиками (если
для них разработан удобный фреймворк для написания тестов).
4. Юнит-тесты всегда автоматизированы, так как проверяют непосредственно
работу кода. Интеграционные тесты могут быть ручными и автоматизированными.
Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые
проверяют полный стек технологий приложения и пользовательский сценарий
взаимодействия с приложением как с черным ящиком. Если говорить про UIтесты, которые разрабатываются с помощью Selenium, то их стоит отнести к
разряду end-to-end тестов, так как они проверяют совместную работу всех систем
web-продукта: работу frontend и backend, работу базы данных, дополнительные
сервисы, такие как аналитика, платежные системы и так далее.
5. Оригинальная пирамида тестов Майка Кона состоит из трёх уровней (снизу
вверх):
a. Юнит-тесты.
b. Сервисные тесты.
c. Тесты пользовательского интерфейса
6. Инструменты тестирвания:
• — это встроенный в стандартную библиотеку инструмент для
тестирования кода на Python.
unittest
• — инструмент тестирования с упором на обратную совместимость и
минимизацию бойлерплейт-кода.
pytest
• — это расширение unittest, облегчающее создание и выполнение test
cases.
nose
• — библиотека Python для создания юнит-тестов. Помогает
разработчикам создавать тесты с крайними случаями.
Hypothesis
• генерирует синтетические тестовые данные, которые можно с пользой
применить в ваших тестах.
mimesis • — это тестовый фреймворк, предназначавшийся для замены
распространенной комбинации unittest+nose. Но команда, занимавшаяся testify
testify, переходит на pytest, так что использовать этот фреймворк для новых
проектов не рекомендуется.
Что такое GIL в Python?
1. Global Interpreter Lock (GIL) — это своеобразная блокировка, позволяющая
только одному потоку управлять интерпретатором Python. Это означает, что в
любой момент времени будет выполняться только один конкретный поток.
2. GIL является самым простым способом избежать конфликтов при одновременном
обращении разных потоков к одним и тем же участкам памяти. Когда один поток
захватывает его, GIL, работая по принципу мьютекса, блокирует остальные. Нет
параллельных потоков — нет конфликтов при обращении к разделяемым
объектам. Очерёдность выполнения потоков определяет интерпретатор в
зависимости от реализации, переключение между потоками может происходить:
когда активный поток пытается осуществить ввод-вывод, по исчерпании лимита
выполненных инструкций, либо по таймеру.
Django
Жизненный цикл приложения
https://django.fun/tutorials/put-ot-request-do-response-vdjango/
1. Когда пользователь делает запрос к вашему приложению, создается экземпляр
обработчика WSGI, который:
a. Импортирует ваш файл settings.py и классы исключений Django.
b. Загружает все промежуточные классы, которые он находит в
кортеже MIDDLEWARE_CLASSES или MIDDLEWARES (в зависимости от версии
Django), расположенном в settings.py
c. Создает четыре списка методов, которые обрабатывают запрос,
представление, ответ и исключения.
d. Перебирает методы запроса, выполняя их по порядку
e. Определяет запрошенный URL
f. Проходит через каждый из методов обработки представления
g. Вызывает функцию отображения (обычно рендеринг шаблона)
h. Обрабатывает любые методы исключения
i. Проходит через каждый из методов ответа (изнутри, в обратном порядке из
промежуточного ПО запроса)
j. Наконец, создает возвращаемое значение и вызывает функцию обратного
вызова на веб-сервере
2. Слои приложения
a. Request Middlewares - Запрос промежуточного программного обеспечения
b. URL Router (URL Dispatcher) - Маршрутизация URL
c. Views - Отображения
d. Context Processors - Контекстные процессоры
e. Template Renderers - Рендер шаблонов
f. Response Middlewares - Промежуточное программное обеспечение ответа
Как работают наследование моделей?
• В Django возможны три стиля наследования.
1. Часто вы просто захотите использовать родительский класс для хранения
информации, которую вы не хотите вводить для каждой дочерней модели.
Этот класс никогда не будет использоваться изолированно, поэтому
Абстрактные базовые классы - это то, что вам нужно.
2. Если вы создаете подкласс существующей модели (возможно, целиком из
другого приложения) и хотите, чтобы у каждой модели была своя собственная
таблица базы данных, используйте Мультитабличное наследование.
3. Наконец, если вы хотите изменить только поведение модели на уровне
Python, не изменяя поля моделей, вы можете использовать Модели прокси.
Что такое миграции и как они работают?
• Миграция — это описание изменений, которые вы хотите внести в таблицы базы
данных. Каждая миграция — это файл с инструкциями
для базы данных.
• Есть несколько команд, которые вы будете использовать для взаимодействия с
миграциями и обработкой Django схемы базы данных:
◦ migrate , которая отвечает за применение и отмену миграции.
◦ makemigrations , которая отвечает за создание новых миграций на основе
изменений, которые вы внесли в свои модели.
◦ sqlmigrate , которая отображает операторы SQL для миграции.
◦ showmigrations , в которой перечислены миграции проекта и их статус.
Как добавить не пустое поле в модель без остановки приложения?
Как быть когда в базе уже есть данные, но миграции еще не применены?
Где лучше расположить логику (модели vs сериализаторы vs представления)
отдельные сервисы
• Сериалайзеры точно не подходят для написания в них бизнес-логики. Если вам
нужно что-то большее, чем CRUD, то стоит отказаться от использования
метода save у сериалайзеров, так как сохранение данных не должно входить в их
обязанности. Стоит отказаться от ModelSerializer с его магическими
методами create и update и заменить их на обычные сериалайзеры (можно
использовать ModelSerializer как read only — для удобства). Если вы пишете
какое-то простое приложение, где кроме CRUD ничего не нужно, то можно не
отказываться от удобства DRF и использовать сериалайзеры как предлагается в
документации.
• В представлениях не стоит размещать бизнес-логику. Стоит отказаться от
ModelViewSet и миксинов, так как они используют сериалайзеры для сохранения
данных, вместо этого использовать обычные APIView или GenericAPIView .
Если вам нужен только CRUD, то можно использовать подход который
предоставляет ModelViewSet и не усложнять себе жизнь.
• Подход с моделями можно использовать в малых проектах, когда бизнес-логики
не много и она умещается в классах моделей. Если вам нужен только CRUD, то
данный подход увеличивает время разработки и не приносит плюсов.
• Подход с выделением отдельного слоя Services удобно использовать в проектах
различной сложности и размера. В проекте понятна структура, каждый слой и
компонент имеет свою ответственность и не нарушает ее границы. Сервисы легко
декомпозировать и отделять друг от друга, в более сложных случаях их можно
объединять за фасадами.
Как сделать подзапросное выражение (subquery)?
1. Подзапросы - это такие запросы, которые находятся внутри других sql-запросов
2. В Django за подзапросное выражение отвечает django.db.models.Subquery
Как работают методы select_related и prefetch_related ?
1. В Django select_related и prefetch_related предназначены для остановки
потока запросов к базе данных, вызванных доступом к связанным объектам
2. Мы используем select_related , когда объект, который вы собираетесь выбрать,
является одним объектом, что означает пересылку ForeignKey , OneToOne и
обратный OneToOne. select_related работает путем создания соединения SQL
и включения полей связанного объекта в оператор SELECT . По этой
причине select_related получает связанные объекты в том же запросе к базе
данных.
3. Мы используем prefetch_related , когда собираемся получить набор вещей. Это
означает обработку ManyToMany и обратных ManyToMany , ForeignKey .
prefetch_related выполняет отдельный поиск для каждой связи и выполняет
«объединение» в Python. Он отличается
от select_related . prefetch_related выполнял JOIN с использованием
Python, а не в базе данных.
Как в Django писать на нативном SQL?
• Django предоставляет вам два способа выполнения необработанных SQLзапросов: вы можете использовать Manager.raw() для выполнения
необработанных запросов и возврата экземпляров модели, или вы можете
полностью отказаться от уровня модели и напрямую выполнять пользовательский
SQL-запрос.
Что такое middleware и как оно работает?
• Django Middleware — это промежуточный слой между запросом и ответом, это
легкая, низкоуровневая система “плагинов” для глобального изменения входных
или выходных данных. Каждый компонент промежуточного слоя отвечает за
выполнение определенной функции.
• Middleware применяется в том же порядке, в каком оно добавлено в список в
настройках Django. Когда браузер отправляет запрос, он обрабатывается так:
Browser -> M_1 -> M_2 -> ... -> M_N -> View
• Представление получает запрос, выполняет некоторые операции и возвращает
ответ. На пути к браузеру ответ снова проходить через каждое middleware, но в
обратном порядке:
Browser <- M_1 <- M_2 <- ... <- M_N <- View
Browser <- M_1 <- M_2 <- ... <- M_N <- View
Какие существуют middleware?
1. django.middleware.security.SecurityMiddleware включен по-умолчанию и
должен быть самым первым в списке MIDDLEWARE , для того чтобы
злонамеренные запросы блокировались до обработки другими middleware. Он
защищает сразу от многих атак и каждую из этих защит можно включить/
отключить отдельно используя переменные в settings.py
2. django.contrib.sessions.middleware.SessionMiddleware включает поддержку
механизма сессий в Django-проекте. То есть по Session ID, который передаётся в
Cookies, находит данные сессии в бекенде для хранения сессий (например, в
базе данных).
3. django.middleware.common.CommonMiddleware добавляет несколько полезных
возможностей. Таких как добавление слеша ( / ) в конце URL, www к домену -
если включены соответствующие настройки, поддержка механизма HTTP ETag .
4. django.middleware.csrf.CsrfViewMiddleware проверяет запросы с данными от
клиента на наличие CSRF-токена, дабы предотвратить подделку запроса.
5. django.contrib.auth.middleware.AuthenticationMiddleware находит по сессии
Django-пользователя, подставляя его в поле user объекта request .
6. django.contrib.messages.middleware.MessageMiddleware позволяет хранить в
сессии пользователя небольшие информационные сообщения, которые будут
храниться между запросами.
7. django.middleware.clickjacking.XFrameOptionsMiddleware добавляет защиту
от clickjacking -а - подмены сайта посредством frame -элементов.
Как написать свой middleware?
Существует 2 способа создания middleware: как функция и как класс
def simple_middleware(get_response): # Единовременная настройка и
инициализация. def middleware(request): # Код должен быть выполнен для
каждого запроса до view response = get_response(request) # Код должен
быть выполнен ответа после view return response return middleware
class SimpleMiddleware: def __init__(self, get_response):
self.get_response = get_response # Единовременная настройка и
инициализация.. def __call__(self, request): # Код должен быть выполнен
для каждого запроса до view response = self.get_response(request) # Код
должен быть выполнен ответа после view return response
Как реализовать свою систему авторизации?
Приложение auth - это встроенная система аутентификации в Django, которая
позволяет разработчикам добавлять аутентификацию в свои приложения, не
изобретая велосипед, пытаясь реализовать базовую функциональность с нуля.
Приложение аутентификации Django предоставляет следующие функциональные
возможности из «коробки»:
• Класс авторизации
LoginView ,
• Класс выхода
LogoutView ,
• Сброс пароля
PasswordResetView ,
• Смена пароля
PasswordChangeView
Вам нужно только предоставить шаблоны для реализации этих функций в вашем
приложении.
Для регистрации пользователей необходимо создать свой вид и шаблон.
Вам нужно проверить, приложение django.contrib.auth указано
в INSTALLED_APPS файла settings.py , который используется по умолчанию.
Затем создайте файл urls.py в приложении учетных записей и добавьте
следующий код:
from django.contrib.auth import views from django.urls import path urlp
atterns = [ path('login/', views.LoginView.as_view(), name='login'), pa
th('logout/', views.LogoutView.as_view(), name='logout'), path('passwor
d-change/', views.PasswordChangeView.as_view(), name='password_change')
, path('password-change/done/', views.PasswordChangeDoneView.as_view(),
name='password_change_done'), path('password-reset/', views.PasswordRes
etView.as_view(), name='password_reset'), path('password-reset/done/',
views.PasswordResetDoneView.as_view(), name='password_reset_done'), pat
h('reset/<uidb64>/<token>/', views.PasswordResetConfirmView.as_view(),
name='password_reset_confirm'), path('reset/done/', views.PasswordReset
CompleteView.as_view(), name='password_reset_complete') ]
Как работать с несколькими базами данных и как их тестировать?
Ниже приведен пример settings.py фрагмента, определяющего две базы данных -
базу данных PostgreSQL по умолчанию и базу данных MySQL под названием users :
DATABASES = { 'default': { 'NAME': 'app_data', 'ENGINE':
'django.db.backends.postgresql', 'USER': 'postgres_user', 'PASSWORD':
's3krit' }, 'users': { 'NAME': 'user_data', 'ENGINE':
'django.db.backends.mysql', 'USER': 'mysql_user', 'PASSWORD': 'priv4te'
} }
Ручной выбор базы данных для QuerySet
>>> # This will run on the 'default' database. >>> Author.objects.all()
>>> # So will this. >>> Author.objects.using('default').all() >>> #
This will run on the 'other' database. >>>
Author.objects.using('other').all()
Выбор базы данных для save()
>>> my_object.save(using='legacy_users')
Выбор базы данных для удаления
>>> u = User.objects.using('legacy_users').get(username='fred') >>>
u.delete() # will delete from the `legacy_users` database
Использование get_queryset() с несколькими базами данных
class MyManager(models.Manager): def get_queryset(self): qs =
CustomQuerySet(self.model) if self._db is not None: qs =
qs.using(self._db) return qs
Что такое DRF и какие есть альтернативы?
Django Rest Framework (DRF) — это библиотека, которая работает со стандартными
моделями Django для создания гибкого и мощного API для проекта.
API DRF состоит из 3-х слоев: сериализатора, вида и маршрутизатора.
1. Сериализатор: преобразует информацию, хранящуюся в базе данных и
определенную с помощью моделей Django, в формат, который легко и
эффективно передается через API.
2. Вид (ViewSet): определяет функции (чтение, создание, обновление, удаление),
которые будут доступны через API.
3. Маршрутизатор: определяет URL-адреса, которые будут предоставлять доступ к
каждому виду.
Альтернативы DRF:
• Django Tastypie
• Restless
• Django JSON View.
В чем отличие Django от DRF?
Преимущество DRF не только в относительной простоте создания API сайта, но и
высокая скорость работы. Его совершенно спокойно можно использовать в
высоконагруженных проектах. Например, на сайте в 100 тыс. запросов в день, он
великолепно себя ведет без каких-либо проблем. Кроме того, разрабатывая API на
DRF мы получаем унифицированный код, понятный большому числу разработчиков
сайтов на Django. То есть, если в будущем придет другой специалист, то ему не
составит труда быстро разобраться в программе с использованием Django REST
Framework. В отличие от ситуации, когда API пишется самостоятельно «с нуля» или
на своем фреймворке. Здесь поддержка продукта будет испытывать некоторые
сложности.
Как написать OpenAPI для DRF?
Установите зависимости
pip install pyyaml uritemplate
• pyyaml используется для генерации схемы в формат OpenAPI на основе YAML.
• uritemplate используется внутренне для получения параметров в пути.
Генерация статической схемы с помощью команды управления generateschema
Если ваша схема статична, вы можете использовать команду
управления generateschema :
./manage.py generateschema --file openapi-schema.yml
После создания схемы таким образом вы можете аннотировать ее любой
дополнительной информацией, которая не может быть автоматически выведена
генератором схемы.
Вы можете зарегистрировать схему API в системе контроля версий и обновлять ее с
каждым новым релизом, или использовать схему API из статического медиа вашего
сайта.
Генерация динамической схемы с помощью SchemaView
¶
Если вам требуется динамическая схема, например, потому что выбор внешнего
ключа зависит от значений базы данных, вы можете направить SchemaView , который
будет генерировать и обслуживать вашу схему по требованию.
Для маршрутизации SchemaView , используйте помощник get_schema_view() .
В urls.py :
from rest_framework.schemas import get_schema_view urlpatterns = [ #
...# Use the `get_schema_view()` helper to add a `SchemaView` to project
URLs.# * `title` and `description` parameters are passed to
`SchemaGenerator`.# * Provide view name for use with
`reverse()`.path('openapi', get_schema_view( title="Your Project",
description="API for all things …", version="1.0.0" ), name='openapischema'), # ...]
Как реализовать авторизацию и регистрацию в DRF?
Схемы аутентификации всегда определяются как список классов. REST framework
будет пытаться аутентифицировать каждым классом в списке и установит
request.user и request.auth , используя возвращаемое значение первого класса,
который успешно выполнит аутентификацию.
Если ни один класс не выполнит аутентификацию, request.user будет установлен
как экземпляр django.contrib.auth.models.AnonymousUser , а request.auth будет
установлен как None .
Схемы аутентификации по умолчанию могут быть установлены глобально, используя
настройку DEFAULT_AUTHENTICATION_CLASSES . Например:
REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [
'rest_framework.authentication.BasicAuthentication',
'rest_framework.authentication.SessionAuthentication', ] }
Чтобы реализовать настраиваемую схему аутентификации, создайте подкласс
BaseAuthentication и переопределите метод .authenticate(self, request) .
Метод должен возвращать кортеж (user, auth), если аутентификация прошла успешно,
или None в противном случае.
В некоторых случаях вместо возврата None вы можете вызвать исключение
AuthenticationFailed из метода .authenticate() . Обычно вам следует придерживаться следующего подхода:
• Если аутентификация не была предпринята, верните None . Любые другие
используемые схемы аутентификации по-прежнему будут проверяться.
• Если попытка аутентификации не удалась, вызовите исключение
AuthenticationFailed . Ответ об ошибке будет возвращен немедленно,
независимо от любых проверок разрешений и без проверки каких-либо других
схем аутентификации.
В следующем примере выполняется аутентификация любого входящего запроса от
имени пользователя, заданного именем пользователя в настраиваемом заголовке
запроса с именем X-USERNAME .
from django.contrib.auth.models import User from rest_framework import
authentication from rest_framework import exceptions class
ExampleAuthentication(authentication.BaseAuthentication): def
authenticate(self, request): username =
request.META.get('HTTP_X_USERNAME') if not username: return None try:
user = User.objects.get(username=username) except User.DoesNotExist:
raise exceptions.AuthenticationFailed('No such user') return (user,
None)
Что такое permissions и как оно работает?
Вместе с аутентификацией и регулированием разрешения определяют, должен ли
запрос быть предоставлен или запрещен доступ.
Проверки разрешений всегда выполняются в самом начале представления, прежде
чем будет разрешено выполнение любого другого кода. Проверки разрешений обычно
используют информацию аутентификации в свойствах request.user и
request.auth , чтобы определить, следует ли выполнить входящий запрос.
Разрешения используются для предоставления или запрета доступа разным классам
пользователей к разным частям API.
Самый простой стиль разрешения - разрешить доступ любому
аутентифицированному пользователю и запретить доступ любому
неаутентифицированному пользователю. Это соответствует классу IsAuthenticated
в REST framework.
Чуть менее строгий стиль разрешений - разрешить полный доступ
аутентифицированным пользователям, но разрешить доступ только для чтения
неаутентифицированным пользователям. Это соответствует классу
IsAuthenticatedOrReadOnly в REST framework.
Политика разрешений по умолчанию может быть установлена глобально с помощью
параметра DEFAULT_PERMISSION_CLASSES . Например:
REST_FRAMEWORK = { 'DEFAULT_PERMISSION_CLASSES': [
'rest_framework.permissions.IsAuthenticated', ] }
Какие существуют встроенные сериализаторы и как они работают?
Сериализаторы позволяют преобразовывать сложные данные, такие как querysets и
экземпляры моделей, в нативные типы данных Python, которые затем могут быть
легко срендерены в JSON, XML или другие типы контента. Сериализаторы также
обеспечивают десериализацию, позволяя преобразовать спарсенные данные
обратно в сложные типы после проверки входящих данных.
Сериализаторы в REST framework работают аналогично классам Django Form и
ModelForm . Мы предоставляем класс Serializer , который дает вам мощный,
общий способ управления вашими ответами, а также класс ModelSerializer -
полезный и быстрый способ создания сериализаторов, которые имеют дело с
экземплярами модели и querysets.
Встроенные сериализаторы:
• Класс ModelSerializer позволяет автоматически создавать класс Serializer с
полями, соответствующими полям Model.
• Класс HyperlinkedModelSerializer похож на класс ModelSerializer , за
исключением того, что для представления отношений он использует гиперссылки,
а не первичные ключи.
• Класс ListSerializer обеспечивает поведение для последовательной и
одновременной проверки нескольких объектов. Обычно вам не нужно
использовать ListSerializer напрямую но вместо этого нужно просто передать
аргумент many = True при создании экземпляра сериализатора. Когда
инициализируется сериализатор и передается аргумент many = True , создается
экземпляр ListSerializer . Затем класс сериализатора становится потомком
родительского ListSerializer .
В чем отличие generic классов от viewset и когда что нужно использовать?
• GenericAPIView: для APIView это дает вам ярлыки, которые тесно связаны с
вашими моделями баз данных. Добавляет обычно требуемое поведение для
стандартных представлений списка и деталей. Дает вам некоторые атрибуты,
такие как, в serializer_class , также
дает pagination_class , filter_backend и т.д.
• GenericViewSet: Существует много GenericViewSet, наиболее распространенным
из которых является ModelViewSet . Они наследуют GenericAPIView и имеют
полную реализацию всех действий: list , retrieve , destroy , updated и т.д
• Если вы делаете что-то действительно простое, с ModelViewSet должно быть
достаточно, даже переопределения и вызова super тоже достаточно. Для более
сложных случаев вы можете перейти на классы более низкого уровня.
Linux
Как убрать запрашивание пароля при использовании sudo ?
sudo visudo # /etc/sudoers.d $USER ALL=(ALL) NOPASSWD: ALL
Как в режиме реального времени наблюдать за обновлениями лог-файла?
tail -f debug.log
Корректные права на директорию .ssh
Сама директория должна иметь права 700 ( drwx------ ).
Закрытый ключ ( id_rsa или id_dsa ) должен иметь права 600 ( -rw------ ).
Все остальные файлы в директории должны иметь права 644 ( -rw------ ).
Все файлы должны принадлежать текущему пользователю и его группе.
chown -R $USER:$USER ~/.ssh chmod 700 ~/.ssh chmod 644 ~/.ssh/* chmod
600 ~/.ssh/id_rsa ~/.ssh/id_dsa ~/.ssh/authorized_keys
Git
Что такое Git?
Git — распределённая система управления версиями. Проект был создан Линусом
Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7
апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.
В чем отличие git merge от git rebase ?
Git Merge и Git Rebase преследуют одну и ту же цель. Они предназначены для
интеграции изменений из одной ветки в другую. Хотя конечная цель одинаковая,
принципы работы разные.
• Слияние — обычная практика для разработчиков, использующих системы
контроля версий. Независимо от того, созданы ли ветки для тестирования,
исправления ошибок или по другим причинам, слияние фиксирует изменения в
другом месте. Слияние принимает содержимое ветки источника и объединяет их с
целевой веткой. В этом процессе изменяется только целевая ветка. История
исходных веток остается неизменной.
• Rebase — еще один способ перенести изменения из одной ветки в другую.
Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в
целевую ветку. В отличие от слияния, перемещение перезаписывает историю,
потому что она передает завершенную работу из одной ветки в другую. В
процессе устраняется нежелательная история.
Что такое git flow?
Git-flow — альтернативная модель ветвления Git, в которой используются
функциональные ветки и несколько основных веток. Эта модель была впервые
опубликована и популяризована Винсентом Дриссеном на сайте nvie.
Схема выглядит беспорядочно, когда видишь ее впервые, так что пойдем по порядку.
У нас есть две основные ветки: master и develop.
В ветке master содержится ровно тот же код, что и в рабочей (читай, продакт) версии
проекта. А вся работа делается в ветке develop.
Во время работы на основе develop создаются так называемые feature-ветки. Их
может быть неограниченное количество.
Далее, у нас есть ветка release, которая используется для подготовки к новому релизу
проекта.
Наконец, есть ветка hotfix, которая служит для срочного исправления багов,
найденных, например, на продакте.
Вот как в теории, происходит рабочий процесс в Gitflow:
1. Создается репозиторий
2. Репозиторий инициализируется
3. Начинается работа на ветке develop
4. Возникает необходимость опробовать новую штуку – создается feature-ветка и
делаются коммиты5
5. Закончив работу на feature-ветке, вы сливаете ее с develop
6. Если вы довольны текущей версией, но хотите продолжить работу, создается
ветка release, куда перемещается текущая версия. Правка багов будет
происходить на этой же ветке.
7. Когда с веткой release покончено, время слить ее в master и продолжить работу с
develop
8. Кроме того, этот момент можно отметить на master-ветке
Как откатить коммиты?
• git revert создает коммит, который выполняет изменения противоположные
тому коммиту, который отменяется.
• git reset --mixed - отменяет коммит, но не удаляет изменения в рабочей
директории
• git reset --hard - полностью удаляет коммит
• git reset HEAD~ означает "один коммит от последнего коммита". Если бы мы
хотели удалить два последних коммита, то могли бы написать HEAD~2
Как разрешить конфликты при слиянии?
Сообщение Git Описание Решение
Локальные изменения в
следующих файлах
будут перезаписаны
слиянием…
Эта ошибка означает, что
текущая локальная ветвь
содержит один или
несколько файлов с
незафиксированными
изменениями, и эти файлы
затрагиваются слиянием. Git
не создает ошибку для
незафиксированных
изменений в файлах, на
которые не влияет слияние.
Фиксация, скрытие или
отмена незафиксированных
изменений, а затем
повторная попытка слияния.
Сбой автоматического
слияния; исправьте
конфликты, а затем
зафиксируйте
результат.
По крайней мере одно
изменение исходной ветви
конфликтует с изменением
целевой ветви. Git
останавливает слияние и
ожидает разрешения
конфликтов слияния.
Отмените слияние,
запустив git merge --abort
или устранив все конфликты
слияния, а затем выполните
команду git merge --
continue
.
Общие вопросы
Что такое логи, для чего они нужны и как их реализовать?
Что такое RESTAPI и где это используется?
Что такое JWT?
JSON Web Tokens — один из способов представления данных для передачи между
двумя или более сторонами в виде JSON-объекта.
Как правило, структурно JWT состоит из трех частей:
• header — заголовок,
• payload — полезная нагрузка,
• signature — подпись.
Что такое SOAP и в чем отличие от RESTAPI?
На верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST
— это архитектурный подход, ориентированный на использование HTTP в качестве
транспортного протокола.
• Специфика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML,
который представляет собой XML, включающий:— Envelope (конверт) – корневой
элемент, который определяет сообщение и пространство имен, использованное в
документе,— Header (заголовок) – содержит атрибуты сообщения, например:
информация о безопасности или о сетевой маршрутизации,— Body (тело) –
содержит сообщение, которым обмениваются приложения,— Fault –
необязательный элемент, который предоставляет информацию об ошибках,
которые произошли при обработке сообщений. И запрос, и ответ должны
соответствовать структуре SOAP.
• Специфика REST — использование HTTP в качестве транспортного протокола.
Он подразумевает наилучшее использование функций, предоставляемых HTTP —
методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.
Формат обмена сообщениями
• В SOAP вы используете формат SOAP XML для запросов и ответов.
• В REST такого фиксированного формата нет. Вы можете обмениваться
сообщениями на основе XML, JSON или любого другого удобного формата. JSON
является самым популярным среди используемых форматов.
Что такое GraphQL?
GraphQL это синтаксис, который описывает как запрашивать данные, и, в
основном, используется клиентом для загрузки данных с сервера. GraphQL имеет три
основные характеристики:
• Позволяет клиенту точно указать, какие данные ему нужны.
• Облегчает агрегацию данных из нескольких источников.
• Использует систему типов для описания данных.
Что такое вебсокеты, какой протокол используется и как его реализовать?
Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455,
обеспечивает возможность обмена данными между браузером и сервером через
постоянное соединение. Данные передаются по нему в обоих направлениях в виде
«пакетов», без разрыва соединения и дополнительных HTTP-запросов.
WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене
данными, например онлайн игры, торговые площадки, работающие в реальном
времени, и т.д.
Что такое TCP и UDP?
• Протокол TCP (Transmission Control Protocol) – это сетевой протокол, который
«заточен» под соединение. Иными словами, прежде, чем начать обмен данными,
данному протоколу требуется установить соединение между двумя хостами.
Данный протокол имеет высокую надежность, поскольку позволяет не терять
данные при передаче, запрашивает подтверждения о получении от принимающей
стороны и в случае необходимости отправляет данные повторно. При этом
отправляемые пакеты данных сохраняют порядок отправки, то есть можно
сказать, что передача данных упорядочена. Минусом данного протокола является
относительно низкая скорость передачи данных, за счет того что выполнение
надежной и упорядоченной передачи занимает больше времени, чем в
альтернативном протоколе UDP.
• Протокол UDP (User Datagram Protocol), в свою очередь, более прост. Для
передачи данных ему не обязательно устанавливать соединение между
отправителем и получателем. Информация передается без предварительной
проверки готовности принимающей стороны. Это делает протокол менее
надежным – при передаче некоторые фрагменты данных могут теряться. Кроме
того, упорядоченность данных не соблюдается – возможен непоследовательный
прием данных получателем. Зато скорость передачи данных по данному
транспортному протоколу будет более высокой.
• TCP применяется там, где требуется точная и подтверждаемая передача данных
– например, отправка фотографий, или переписка между пользователями. UDP, в
свою очередь, нужен для общения в голосовом формате, или при передаче
потокового видео, например, с веб-камер или IP-камер.
В чем отличие HTTP от HTTPS?
HTTP — это протокол передачи данных между браузером и сервером: страниц,
файлов, видеозаписей. HTTPS — это тот же HTTP, но с добавленными методами
шифрования данных и проверки безопасности.
В чем отличие GET-запроса от POST-запроса?
Метод запроса POST предназначен для направления запроса, при котором вебсервер принимает данные, заключённые в тело сообщения, для хранения. Он часто
используется для загрузки файла или представления заполненной веб-формы. В
отличие от него, метод GET предназначен для получения информации от сервера.
Какие паттерны проектирования существуют?
Виды паттернов
• Поведенческие (behavioral) - B
• Порождающие (creational) - C
• Структурные (structural) - S
Список шаблонов
Что такое монолит и микросервисы?
• Монолитная архитектура — это традиционная модель программного
обеспечения, которая представляет собой единый модуль, работающий
автономно и независимо от других приложений. Монолитом часто называют нечто
большое и неповоротливое, и эти два слова хорошо описывают монолитную
архитектуру для проектирования ПО. Монолитная архитектура — это отдельная
большая вычислительная сеть с единой базой кода, в которой объединены все
бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо
обновить весь стек через базу кода, а также создать и развернуть обновленную
версию интерфейса, находящегося на стороне службы. Это ограничивает работу
с обновлениями и требует много времени.
Монолиты удобно использовать на начальных этапах проектов, чтобы облегчить
развертывание и не тратить слишком много умственных усилий при управлении
кодом. Это позволяет сразу выпускать все, что есть в монолитном приложении.
• Микросервисная архитектура (или просто «микросервисы») представляет собой
метод организации архитектуры, основанный на ряде независимо
развертываемых служб. У этих служб есть собственная бизнес-логика и база
данных с конкретной целью. Обновление, тестирование, развертывание и
масштабирование выполняются внутри каждой службы. Микросервисы разбивают
крупные задачи, характерные для конкретного бизнеса, на несколько
независимых баз кода. Микросервисы не снижают сложность, но они делают
любую сложность видимой и более управляемой, разделяя задачи на более
мелкие процессы, которые функционируют независимо друг от друга и вносят
вклад в общее целое.
Внедрение микросервисов зачастую тесно связано с DevOps, поскольку они
лежат в основе методики непрерывной поставки, которая позволяет командам
быстро адаптироваться к требованиям пользователей. Как перейти из монолита в микросервисы?

Инструменты
Что такое Celery и какие существуют таски?
• Celery - это иное как распределённая очередь заданий, реализованная на языке
Python
• Виды тасок:
1. Вы можете легко создать задачу из любого вызываемого объекта с помощью
декоратора
task()
:
from .models import User @app.task def create_user(username,
password): User.objects.create(username=username,
password=password)
2. Если вы используете Django или являетесь автором библиотеки, то вы,
вероятно, захотите использовать декоратор shared_task() :
from celery import shared_task @shared_task def add(x, y): return
x + y
3. Все задачи наследуются от класса . Метод становится телом
задачи.
app.Task run()
В качестве примера можно привести следующий код,
@app.task def add(x, y): return x + y
будет делать примерно то же самое за кулисами:
class _AddTask(app.Task): def run(self, x, y): return x + y add =
app.tasks[_AddTask.name]
Что такое брокеры и какие они бывают?
Брокер сообщений (он же диспетчер очереди) — это штука, которая принимает и
отдает сообщения между отдельными модулями/приложениями внутри некоторой
сложной системы, где модули/приложения должны общаться между собой — то есть
пересылать данные друг другу.
Распределенная система — такая система, которая работает сразу на множестве
машин, образующих цельный кластер. Кластер это набор компьютеров/серверов,
объединенных сетью и взаимодействующих между собой. Важнейшие плюсы такого
подхода – высокодоступность и отказоустойчивость.
Вертикальная масштабируемость — это наращивание ресурсов, то есть
увеличение количества ядер, оперативной памяти и т.д. на одном сервере.
Плюсы:
• Достаточно просто и понятно.
Минусы:
• Нельзя наращивать бесконечно.
• При добавлении ресурсов (оперативка и т.д.) обычно приходится выключать
сервера, что не круто.
Горизонтальная масштабируемость — это добавление новых серверов с более или
менее любыми характеристиками в вычислительный кластер.
Плюсы:
• Нет таких проблем, как у вертикальной масштабируемости
Минусы:
• Не везде поддерживается горизонтальная масштабируемость
• Очень не все системы работают в кластерах, а те, которые в них работают,
обычно достаточно сложные в эксплуатации
Отказоустойчивая система это такая система, где отсутствует единая точка отказа,
их конфигурацию можно корректировать, подстраиваясь под случающиеся
отказы. Единая точка отказа — штука, характерная для нераспределенных систем.
Например, если один сервер у вас откажет, то вся система отключается.
Плюсы:
• Они отказоустойчивые!
Минусы:
• Для обеспечения отказоустойчивости обязательно приходится частично
жертвовать производительностью, поскольку чем лучше ваша система переносит
отказы, тем ниже ее производительность.
Брокеры сообщений
• Apache Kafka — распределенный горизонтально масштабируемый
отказоустойчивый программный брокер сообщений.
• RabbitMQ, как и Kafka, тоже распределенный горизонтально масштабируемый
отказоустойчивый программный брокер сообщений.
• Redis предоставляет высокопроизводительное хранилище данных в памяти,
которое можно использовать для хранения ключей, либо как брокер сообщений.
Еще одна особенность заключается в том, что Redis не обладает
персистентностью (механизм постоянного хранения данных), а наоборот
сбрасывает данные на диск/в базу данных.
База данных
Что такое NoSQL базы данных, какие они бывают и в чем их преимущество?
NoSQL – это подход к реализации масштабируемого хранилища (базы) информации
с гибкой моделью данных, отличающийся от классических реляционных СУБД.
Типы баз данных NoSQL
• БД на основе пар «ключ‑значение». Базы данных с использованием пар
«ключ‑значение» поддерживают высокую разделяемость и обеспечивают
беспрецедентное горизонтальное масштабирование, недостижимое при
использовании других типов БД. Хорошими примерами использования для баз
данных типа «ключ‑значение» являются игровые, рекламные приложения и
приложения IoT. обеспечивает стабильную работу БД с
задержкой не более нескольких миллисекунд при любом масштабе. Такая
устойчивая производительность послужила основной причиной
переноса в сервис DynamoDB, поскольку эта возможность
Snapchat связана с самой большой нагрузкой на запись в хранилище.
Amazon DynamoDB Snapchat Stories
• Документ В коде приложения данные часто представлены как объект или
документ в формате, подобном JSON, поскольку для разработчиков это
эффективная и интуитивная модель данных. Документные базы данных
позволяют разработчикам хранить и запрашивать данные в БД с помощью той же
документной модели, которую они используют в коде приложения. Гибкий,
полуструктурированный, иерархический характер документов и документных баз
данных позволяет им развиваться в соответствии с потребностями приложений.
Документная модель хорошо работает в каталогах, пользовательских профилях и
системах управления контентом, где каждый документ уникален и изменяется со
временем. и MongoDB —
распространенные документные базы данных, которые предоставляют
функциональные и интуитивно понятные API для гибкой разработки.
Amazon DocumentDB (совместимая с MongoDB)
• Графовые БД. Графовые базы данных упрощают разработку и запуск
приложений, работающих с наборами сложносвязанных данных. Типичные
примеры использования графовых баз данных – социальные сети, сервисы
рекомендаций, системы выявления мошенничества и графы знаний.
– это полностью управляемый сервис графовых баз данных. Neptune
поддерживает модель Property Graph и Resource Description Framework (RDF),
предоставляя на выбор два графовых API: TinkerPop и RDF / SPARQL. К числу
распространенных графовых БД относятся Neo4j и Giraph.
Amazon
Neptune
• БД в памяти. Часто в игровых и рекламных приложениях используются таблицы
лидеров, хранение сессий и аналитика в реальном времени. Такие возможности
требуют отклика в пределах нескольких микросекунд, при этом резкое
возрастание трафика возможно в любой момент. –
это совместимый с Redis надежный сервис базы данных в памяти, который
уменьшает задержку чтения до миллисекунд и обеспечивает надежность в
нескольких зонах доступности. MemoryDB специально создана для обеспечения
сверхвысокой производительности и надежности, поэтому ее можно использовать
как основную базу данных для современных приложений на базе
микросервисов. – это полностью управляемый сервис
кэширования в памяти, совместимый с Redis и Memcached для обслуживания
рабочих нагрузок с низкой задержкой и высокой пропускной способностью. Такие
клиенты, как , которым требуется, чтобы их приложения давали отклик в
режиме реального времени, пользуются системами хранения данных в памяти, а
не на диске. Еще одним примером специально разработанного хранилища
данных является . DAX позволяет DynamoDB
считывать данные в несколько раз быстрее.
Amazon MemoryDB для Redis Amazon ElastiCache TinderAmazon DynamoDB Accelerator (DAX)
• Поисковые БД. Многие приложения формируют журналы, чтобы разработчикам
было проще выявлять и устранять неполадки.
– специально разработанный сервис для визуализации и
аналитики автоматически генерируемых потоков данных в режиме, близком к
реальному времени, путем индексирования, агрегации частично
структурированных журналов и метрик и поиска по ним. Amazon ES – это также
мощная высокопроизводительная поисковая система для полнотекстового поиска.
Компания задействует более 150 доменов Amazon ES, 30 ТБ данных и
30 миллиардов документов для разнообразных особо важных примеров
использования – от операционного мониторинга и устранения неисправностей до
отслеживания стека распределенных приложений и оптимизации затрат.
Amazon Elasticsearch
Service (Amazon ES)
Expedia
Для чего можно использовать базы данных NoSQL?
Базы данных NoSQL хорошо подходят для многих современных приложений,
например мобильных, игровых, интернет‑приложений, когда требуются гибкие
масштабируемые базы данных с высокой производительностью и широкими
функциональными возможностями, способные обеспечивать максимальное удобство
использования.
• Гибкость. Как правило, базы данных NoSQL предлагают гибкие схемы, что
позволяет осуществлять разработку быстрее и обеспечивает возможность
поэтапной реализации. Благодаря использованию гибких моделей данных БД
NoSQL хорошо подходят для частично структурированных и неструктурированных
данных.
• Масштабируемость. Базы данных NoSQL рассчитаны на масштабирование с
использованием распределенных кластеров аппаратного обеспечения, а не путем
добавления дорогих надежных серверов. Некоторые поставщики облачных услуг
проводят эти операции в фоновом режиме, обеспечивая полностью управляемый
сервис.
• Высокая производительность. Базы данных NoSQL оптимизированы для
конкретных моделей данных и шаблонов доступа, что позволяет достичь более
высокой производительности по сравнению с реляционными базами данных.
• Широкие функциональные возможности. Базы данных NoSQL предоставляют
API и типы данных с широкой функциональностью, которые специально
разработаны для соответствующих моделей данных.
Что такое индексы, кэширование и транзакции в PostgreSQL?
Индекс это набор дополнительных данных, записанных в удобном виде, который
позволяет существенно быстрее осуществлять поиск, хоть и требующий
дополнительных усилий для поддерживания его актуальности.
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST,
GIN и BRIN. Для разных типов индексов применяются разные алгоритмы,
ориентированные на определённые типы запросов. По умолчанию команда CREATE
INDEX создаёт индексы типа B-дерево, эффективные в большинстве случаев.
Кэширование данных позволяет сохранять результаты запросов таблиц поиска в
памяти. Последующие запросы той же информации будут выполняться на основе
данных, полученных из памяти, вместо того, чтобы лишний запрос отрицательно
влиял на СУБД.
Транзакция — это набор операций по работе с базой данных (БД), объединенных в
одну атомарную пачку.
Что такое денормализация?
Денормализация (англ. denormalization) — намеренное приведение структуры базы
данных в состояние, не соответствующее критериям нормализации, обычно
проводимое с целью ускорения операций чтения из базы за счет добавления
избыточных данных.
Когда нужно использовать Redis и когда - PostgreSQL?
Примеры использования строк Redis
1. Кэш сессии: многие веб-сайты используют строки Redis для создания
, чтобы ускорить работу веб-сайта путем кэширования HTML-фрагментов
или страниц. Redis идеально подходит для этого, так как данные временно
хранятся в оперативной памяти. Например, он способен временно хранить
пользовательские данные, такие как товары в корзине покупок интернет-магазина,
чтобы они не потерялись в случае выхода из системы или потери соединения.
кэша
сессии
2. Очереди: этот вариант использования Redis стоит рассмотреть для любого
приложения, которое занимается обменом сообщениями, сбором данных,
управлением заданиями, маршрутизацией пакетов данных или сталкивается с
перегрузкой данными. Redis поможет управлять размером очереди в зависимости
от скорости поступления и отправки пакетов — для эффективного распределения
ресурсов.
3. Биллинг по объему оказанных услуг (usage-или metered billing): менее
известный пример использования строк Redis — подсчет биллинга в реальном
времени в моделях с тарифами на конкретные услуги. Это позволяет SaaS-
платформам, которые выставляют счета на основе фактического использования,
измерять активность своих клиентов. Например, операторы сотовой связи могут
взимать плату за отдельные текстовые сообщения или минуты разговора.
SQL
Как работает оператор SELECT ?
SELECT (от англ. select — «выбрать») — оператор запроса (DML/DQL) в языке SQL,
возвращающий набор данных (выборку) из базы данных.
Оператор возвращает ноль или более строк. Список возвращаемых столбцов
задается в части оператора, называемой предложением SELECT. Поскольку SQL
является декларативным языком, запрос SELECT определяет лишь требования к
возвращаемому набору данных, но не является точной инструкцией по их
вычислению. СУБД транслирует запрос SELECT во внутренний план исполнения
(«query plan»), который может различаться даже для синтаксически одинаковых
запросов и от конкретной СУБД.
Оператор SELECT состоит из нескольких предложений (разделов):
1. SELECT определяет список возвращаемых столбцов (как существующих, так и
вычисляемых), их имена, ограничения на уникальность строк в возвращаемом
наборе, ограничения на количество строк в возвращаемом наборе;
2. FROM задаёт табличное выражение, которое определяет базовый набор данных
для применения операций, определяемых в других предложениях оператора;
3. WHERE задает ограничение на строки табличного выражения из предложения
FROM ;
4. GROUP BY объединяет ряды, имеющие одинаковое свойство с применением
агрегатных функций;
5. HAVING выбирает среди групп, определённых параметром GROUP BY ;
6. ORDER BY задает критерии сортировки строк; отсортированные строки
передаются в точку вызова.
Как записать данные в таблицу?
INSERT — оператор языка SQL, который позволяет добавить строки в таблицу,
заполняя их значениями. Значения можно вставлять перечислением с помощью
слова values и перечислив их в круглых скобках через запятую или оператором select.
Пример использования используя перечисление значений, с указанием столбцов:
insert into <название таблицы> ([<Имя столбца>, ... ]) values
(<Значение>,...)
Например:
INSERT INTO phone_book (name, number) VALUES ('John Doe', '555-1212');
Как обновить данные в таблице?
UPDATE — оператор языка SQL, позволяющий обновить значения в заданных
столбцах таблицы.
Синтаксис:
UPDATE [top(x)] <объект> SET <присваивание1 [, присваивание2, ...]>
[WHERE <условие>];
• top(x) — команда выполнится только х раз
• <объект> — объект, над которым выполняется действие (таблица
или представление)
• <присваивание> — присваивание, которое будет выполняться при каждом
выполнении условия <условие>, или для каждой записи, если отсутствует раздел
where
• <условие> — условие выполнения команды
• SET — после ключевого слова должен идти список полей таблицы, которые будут
обновлены и непосредственно сами новые значения в виде имя поля="значение"
Что такое транзакция?
Транзакции SQL – это группа последовательных операций с базой данных, которая
представляет собой логическую единицу работы с данными. Иными словами,
транзакции позволяют нам контролировать процессы сохранения и изменения в
базах данных
Для того, чтобы создать транзакцию SQL, достаточно группу операций поместить
между операторами BEGIN и COMMIT.
BEGIN; UPDATE table_name SET field_1 = NULL WHERE id = 5; DELETE FROM
other_table WHERE id = 17; COMMIT;
Что такое индексы?
Индексы представляют собой структуру данных, содержащую указатели на
содержимое таблицы, упорядоченной в определенном порядке, чтобы помочь
оптимизировать запросы базы данных. Они похожи на индекс книги, где страницы
(строки таблицы) индексируются по их номеру страницы.
Создание индекса
CREATE INDEX ix_cars_employee_id ON Cars (EmployeeId);
Это создаст индекс для столбца EmployeeId в таблице Cars . Этот индекс улучшит
скорость запросов, запрашивающих сервер для сортировки или выбора значений
в EmployeeId , например:
SELECT * FROM Cars WHERE EmployeeId = 1
Индекс может содержать более 1 столбца, как в следующем;
CREATE INDEX ix_cars_e_c_o_ids ON Cars (EmployeeId, CarId, OwnerId);
В этом случае индекс был бы полезен для запросов, запрашивающих сортировку или
выбор всех включенных столбцов, если набор условий упорядочен таким же образом.
Это означает, что при извлечении данных он может найти строки, которые будут
извлекаться с использованием индекса, а не просматривать всю таблицу.
Например, в следующем случае будет использоваться второй индекс;
SELECT * FROM Cars WHERE EmployeeId = 1 Order by CarId DESC
Однако, если порядок отличается, индекс не имеет таких же преимуществ, как в
следующем;
SELECT * FROM Cars WHERE OwnerId = 17 Order by CarId DESC
В чем отличие оператора WHERE от HAVING ?
Во-первых, в HAVING и только в нём можно писать условия по агрегатным функциям
(SUM, COUNT, MAX, MIN и т. д.). То есть если вы хотите сделать что-то вроде
COUNT(*) > 10 , то это возможно сделать только в HAVING.
"Почему бы не оставить только HAVING?" - спросите вы. Всё кроется в том, как SQL
Server выполняет запрос, в каком порядке происходит его разбор и работа с
данными. WHERE выполняется до формирования групп GROUP BY. Это нужно для
того, чтобы можно было оперировать как можно меньшим количеством данных и
сэкономить ресурсы сервера и время пользователя.
Следующим этапом формируются группы, которые указаны в GROUP BY. После того
как сформированы группы, можно накладывать условия на результаты агрегатных
функций. И тут как раз наступает очередь HAVING: выполняются условия, которые вы
задали. Главное отличие HAVING от WHERE в том, что в HAVING можно наложить условия на
результаты группировки, потому что порядок исполнения запроса устроен таким
образом, что на этапе, когда выполняется WHERE, ещё нет групп, а HAVING
выполняется уже после формирования групп.
